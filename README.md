# RECODE_CGraph
这是一个我个人对于CGraph的重写，目的是为了方便自己学习CGraph，并且方便自己以后使用。
经过一个多月的学习，了解了CGraph的一些原理，以及一些常用的算法，如今终于开始从零开始写一个CGraph了。
目前已经完成了一个简单的图算法，并且已经完成了一个简单的图算法的测试。
之后这里会记录一些学习到的经验以及思考的内容。

## v0.01

在该版本中，实现了基本的图节点依赖，搭建了最基本的框架，最初使用list实现图结构的依赖关系，希望能够通过list方便的进行节点的顺序执行（最开始是像邻接表），在v0.10版本改为使用set

**认知：** [[nodiscard]]是 C++17 引入的一个标准属性（attribute），用于告诉编译器：该函数的返回值不应被忽略。



## v0.02

在该版本中，实现了基本的线程池

**认知：** `explicit` 是一个关键字，用于防止单参数构造函数（或可以接受单参数的多参数构造函数，C++11 起）触发隐式类型转换。

std::future<int> 表示一个将来会返回 int 类型结果的异步返回值。

在之前的linux的RPC框架开发中，个人通常使用pthread_mutex_t, semaphore.h等库来自行实现互斥锁，该版本的开发中使用c++11引入的lock_guard<mutex> 来实现管理锁，更方便使用更安全，在使用锁的区域使用{}标注作用域

当前 GraphThreadPool 在任务调度上采用逐个提交、多次加锁的方式，存在性能瓶颈；
而在RPC框架开发中 EventLoop 多线程模型通过批量提交 + 单次唤醒的方式，在任务调度效率上更具优势；
将来可以通过引入批量任务接口或无锁队列等方式进行优化，显著提升性能

当前版本中的依赖注册方式过于繁琐，GraphNode 进行节点的依赖关系注册，之后Graphic又将节点注册到自己的图化中，内存重复占用

由于本项目需要频繁进行节点的注册以及拷贝或移动已存在的对象，本项目中采用emplace_back而不是push_back，是考虑到性能的高效，避免额外的拷贝和移动操作，提高项目的性能

## v0.10

在该版本中，优化了节点的依赖关系注册以及实现循环执行,并且是真正意义上的能够用来执行一些具有图依赖的功能

主要新增registerGraphNode函数用于注册节点，addDependNodes函数用于添加依赖关系，checkFinalStatus函数用于检查和重置便于循环。修改前驱和后继的数据结构为set，便于快速查找和获取大小

**认知:**  `cout`并不是线程安全的，所以在run函数中直接使用cout会混乱，并且在使用中实现run函数时要注意线程安全，测试代码中已经添加简单的锁，已在v1.10版本中将锁规范化

由于`set(std::initializer_list<T> list)`，可以使用initializer_list实现多个节点到set的转换


## v1.00

该版本准备进行版本重构，主要为实现图循环逻辑实现结构重组并设计以下模块,
element（元素）
是所有被执行结构的基类，可以派生出node,group两种类型。无实际意义，且不可被执行。

node（节点）
是最小粒度的算子。node本身无法执行，但所有有具体功能的功能节点，都继承自node。

functionNode（功能节点）
是最小粒度的可执行算子，继承自node类，相当于是node的功能实现类。与node不同的是，functionNode有具体功能，且可以被执行。至于具体功能是什么，可以是输出字母a，也可以是去挖比特币。总之，需要自己去实现。

group（组）
是多个functionNode的组合。自身不可以执行，但可以派生出cluster和region等组合逻辑。

cluster（簇）
继承自group，由多个functionNode线性组合而成。执行cluster的时候，内部的node依次顺序执行。简而言之就是可以依次(按注册入pipeline的先后顺序)完成多个功能。

region（区域）
继承自group，也是由多个functionNode组合而成。与cluster的区别是，region中的加入的node需要指定相互依赖关系。如果不指定依赖的话，就相当于是并发执行了，因为没有任何需要依赖信息。

pipeline（流水线）
是以上信息运行的地方。所有的functionNode、cluster、region信息，都需要注册到pipeline中，并且设定相互依赖关系。注册了以上三种信息的pipeline，实际上就对应了一个dag图，执行pipeline的过程，就是图执行的过程。
在pipeline中，所有的节点信息都视为element来通过GelementManager类进行统一管理，而在管理类中又可以设置依赖关系，循环次数，串行节点自动解析为cluster。又因为都是继承自element，所以节点之间可以相互套娃，如region内是几个并行的cluster，cluster内是几个串行功能节点。


**认知：**  `std::all_of` 是 C++ 标准库 `<algorithm>` 中的一个函数模板，用于检查给定范围内的所有元素是否都满足某个条件。如果范围内所有元素都满足条件，则返回 true；否则返回 false，该条件可使用lambda表达式来自由设定。类似的还有`std::any_of`, `std::none_of`

`is_base_of`在c++11引入，用来判断first是否是second的基类，`is_same_v`在C++17引入，用来判断两个类型是否相同。

像这种大型版本更新应该开一个新的分支的，新旧代码杂糅在一起让人抓狂。

## v1.10

当前版本重构完成第一阶段，模块均已设计完成，加入了第一个简单测试用例，已经能够实现基本功能，但仍未仔细检查，可能存在未知错误等待检查。

**认知：** 锁相关：c++17引入`std::mutex`（互斥锁）与`std::shared_mutex`（读写锁）；`std::lock_guard`构造时加锁，离开作用域析构解锁，不支持手动解锁或重新加锁，无额外状态存储，开销更小 不可移动或复制。`std::unique_lock`用于代替互斥对象的成员函数，管理互斥对象，支持延迟加锁（defer_lock）、手动解锁（unlock()）和重新加锁（lock()），更灵活。适合需要条件变量或复杂锁管理的场景，需要维护锁状态（如是否已加锁），略有性能损耗，可通过移动语义转移锁的所有权。

要谨防自赋值行为，深层复制时释放自身资源后再尝试访问它们，导致未定义行为有资源重复释放、内存泄漏等风险。

目前GElementManager类中的Analyze函数会重复添加相交的cluster，目前做了去重但是较为复杂且开销大，待完善。

使用 `new(std::nothrow)` 可以避免程序因内存不足而崩溃，特别是在资源受限的环境中或需要处理大量内存分配的情况下非常有用,可以通过检查返回值是否为 nullptr 来判断内存分配是否成功。

## v1.11

完成功能性测试，目前功能已经基本完成，但似乎存在一些bug，如在T04测试时出现过一次运行错误，重复执行了已经执行过的节点，但已无法复现。

GParam 模块用于参数传递，创建和获取逻辑分离，任何算子节点都可以通过名字获取param类（内部通过哈希表）进行参数传递，为保证多线程安全，使用读写锁提高读速度，独占锁提高写速度，另外可以通过reset方法将所有参数重置为默认值。

