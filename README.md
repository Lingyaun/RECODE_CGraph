# RECODE_CGraph
这是一个我个人对于CGraph的重写，目的是为了方便自己学习CGraph，并且方便自己以后使用。
经过一个多月的学习，了解了CGraph的一些原理，以及一些常用的算法，如今终于开始从零开始写一个CGraph了。
目前已经完成了一个简单的图算法，并且已经完成了一个简单的图算法的测试。
之后这里会记录一些学习到的经验以及思考的内容。

## v0.01

在该版本中，实现了基本的图节点依赖，搭建了最基本的框架，最初使用list实现图结构的依赖关系，希望能够通过list方便的进行节点的顺序执行（最开始是像邻接表），在v0.10版本改为使用set

**认知：**[[nodiscard]]是 C++17 引入的一个标准属性（attribute），用于告诉编译器：该函数的返回值不应被忽略。



## v0.02

在该版本中，实现了基本的线程池

**认知：**explicit 是一个关键字，用于防止单参数构造函数（或可以接受单参数的多参数构造函数，C++11 起）触发隐式类型转换。

std::future<int> 表示一个将来会返回 int 类型结果的异步返回值。

在之前的linux的RPC框架开发中，个人通常使用pthread_mutex_t, semaphore.h等库来自行实现互斥锁，该版本的开发中使用c++11引入的lock_guard<mutex> 来实现管理锁，更方便使用更安全，在使用锁的区域使用{}标注作用域

当前 GraphThreadPool 在任务调度上采用逐个提交、多次加锁的方式，存在性能瓶颈；
而在RPC框架开发中 EventLoop 多线程模型通过批量提交 + 单次唤醒的方式，在任务调度效率上更具优势；
将来可以通过引入批量任务接口或无锁队列等方式进行优化，显著提升性能

当前版本中的依赖注册方式过于繁琐，GraphNode 进行节点的依赖关系注册，之后Graphic又将节点注册到自己的图化中，内存重复占用

由于本项目需要频繁进行节点的注册以及拷贝或移动已存在的对象，本项目中采用emplace_back而不是push_back，是考虑到性能的高效，避免额外的拷贝和移动操作，提高项目的性能

## v0.10

在该版本中，优化了节点的依赖关系注册以及实现循环执行,并且是真正意义上的能够用来执行一些具有图依赖的功能

主要新增registerGraphNode函数用于注册节点，addDependNodes函数用于添加依赖关系，checkFinalStatus函数用于检查和重置便于循环。修改前驱和后继的数据结构为set，便于快速查找和获取大小

**认知:**cout并不是线程安全的，所以在run函数中直接使用cout会混乱，并且在使用中实现run函数时要注意线程安全，测试代码中已经添加简单的锁

由于set(std::initializer_list<T> list)，可以使用initializer_list实现多个节点到set的转换


## v1.00

该版本准备进行版本重构，主要为实现图循环逻辑实现结构重组并设计以下模块,
element（元素）
是所有被执行结构的基类，可以派生出node,group两种类型。无实际意义，且不可被执行。

node（节点）
是最小粒度的算子。node本身无法执行，但所有有具体功能的功能节点，都继承自node。

functionNode（功能节点）
是最小粒度的可执行算子，继承自node类，相当于是node的功能实现类。与node不同的是，functionNode有具体功能，且可以被执行。至于具体功能是什么，可以是输出字母a，也可以是去挖比特币。总之，需要自己去实现。

group（组）
是多个functionNode的组合。自身不可以执行，但可以派生出cluster和region等组合逻辑。

cluster（簇）
继承自group，由多个functionNode线性组合而成。执行cluster的时候，内部的node依次顺序执行。简而言之就是可以依次完成多个功能。

region（区域）
继承自group，也是由多个functionNode组合而成。与cluster的区别是，region中的加入的node需要指定相互依赖关系。如果不指定依赖的话，就相当于是并发执行了，因为没有任何需要依赖信息。

pipeline（流水线）
是以上信息运行的地方。所有的functionNode、cluster、region信息，都需要注册到pipeline中，并且设定相互依赖关系。注册了以上三种信息的pipeline，实际上就对应了一个dag图，执行pipeline的过程，就是图执行的过程。

**认知：**std::all_of 是 C++ 标准库 <algorithm> 中的一个函数模板，用于检查给定范围内的所有元素是否都满足某个条件。如果范围内所有元素都满足条件，则返回 true；否则返回 false，该条件可使用lambda表达式来自由设定。类似的还有any_of, none_of

像这种大型版本更新应该开一个新的分支的，新旧代码杂糅在一起让人抓狂。
