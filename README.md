# RECODE_CGraph
这是一个我个人对于CGraph的重写，目的是为了方便自己学习CGraph，并且方便自己以后使用。
经过一个多月的学习，了解了CGraph的一些原理，以及一些常用的算法，如今终于开始从零开始写一个CGraph了。
目前已经完成了一个简单的图算法，并且已经完成了一个简单的图算法的测试。
之后这里会记录一些学习到的经验以及思考的内容。

#### v0.01

在该版本中，实现了基本的图节点依赖，搭建了最基本的框架，最初使用list实现图结构的依赖关系，希望能够通过list方便的进行节点的顺序执行（最开始是像邻接表），在v0.10版本改为使用set

认知：[[nodiscard]]是 C++17 引入的一个标准属性（attribute），用于告诉编译器：该函数的返回值不应被忽略。



#### v0.02

在该版本中，实现了基本的线程池

认知：explicit 是一个关键字，用于防止单参数构造函数（或可以接受单参数的多参数构造函数，C++11 起）触发隐式类型转换。

std::future<int> 表示一个将来会返回 int 类型结果的异步返回值。

在之前的linux的RPC框架开发中，个人通常使用pthread_mutex_t, semaphore.h等库来自行实现互斥锁，该版本的开发中使用c++11引入的lock_guard<mutex> 来实现管理锁，更方便使用更安全，在使用锁的区域使用{}标注作用域

当前 GraphThreadPool 在任务调度上采用逐个提交、多次加锁的方式，存在性能瓶颈；
而在RPC框架开发中 EventLoop 多线程模型通过批量提交 + 单次唤醒的方式，在任务调度效率上更具优势；
将来可以通过引入批量任务接口或无锁队列等方式进行优化，显著提升性能

当前版本中的依赖注册方式过于繁琐，GraphNode 进行节点的依赖关系注册，之后Graphic又将节点注册到自己的图化中，内存重复占用

#### v0.10

在该版本中，优化了节点的依赖关系注册以及实现循环执行,并且是真正意义上的能够用来执行一些具有图依赖的功能

主要新增registerGraphNode函数用于注册节点，addDependNodes函数用于添加依赖关系，checkFinalStatus函数用于检查和重置便于循环。修改前驱和后继的数据结构为set，便于快速查找和获取大小

认知:cout并不是线程安全的，所以在run函数中直接使用cout会混乱，并且在使用中实现run函数时要注意线程安全，测试代码中已经添加简单的锁

由于set(std::initializer_list<T> list)，可以使用initializer_list实现多个节点到set的转换

