# RECODE_CGraph
这是一个我个人对于CGraph的重写，目的是为了方便自己学习CGraph，并且方便自己以后使用。
经过一个多月的学习，了解了CGraph的一些原理，以及一些常用的算法，如今终于开始从零开始写一个CGraph了。
目前已经完成了一个简单的图算法，并且已经完成了一个简单的图算法的测试。
之后这里会记录一些学习到的经验以及思考的内容。

v0.01
在该版本中，实现了基本的图节点依赖，搭建了最基本的框架

认知：[[nodiscard]]是 C++17 引入的一个标准属性（attribute），用于告诉编译器：该函数的返回值不应被忽略。

v0.02
在该版本中，实现了基本的线程池

认知：explicit 是一个关键字，用于防止单参数构造函数（或可以接受单参数的多参数构造函数，C++11 起）触发隐式类型转换。

std::future<int> 表示一个将来会返回 int 类型结果的异步返回值。

在之前的linux的RPC框架开发中，个人通常使用pthread_mutex_t, semaphore.h等库来自行实现互斥锁，该版本的开发中使用c++11引入的lock_guard<mutex> 来实现管理锁，更方便使用更安全，在使用锁的区域使用{}标注作用域

当前 GraphThreadPool 在任务调度上采用逐个提交、多次加锁的方式，存在性能瓶颈；
而在RPC框架开发中 EventLoop 多线程模型通过批量提交 + 单次唤醒的方式，在任务调度效率上更具优势；
将来可以通过引入批量任务接口或无锁队列等方式进行优化，显著提升性能